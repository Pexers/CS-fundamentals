<h1 align='center'>Methodologies</h1>

Copyright &copy; 2023, Pexers (https://github.com/Pexers)

Software development methodologies (SDMs) can help a team to complete project seamlessly. Selecting the right development methodology for a product organization depends largely on the team size, goals, and other factors. 

Almost all software development methodologies are non-technical. This means they do not deal with the technical aspects of software design and development. They focus more on the internal operations, and other processes involved in the project.

## 1. Waterfall
When it comes to software development, Waterfall is the most traditional and sequential choice. Although it’s usually viewed as an outdated method, it’s helpful to understand its structure to better appreciate the flexibility of more modern methodologies.

Waterfall requires plenty of structure and documentation up front. It is divided into self-contained stages. The first stage is vital, requiring a full understanding by both developers and customers of the project’s demands and scope before anything begins.
<p align="center">
  <img src="https://user-images.githubusercontent.com/47757441/211622541-7b499331-472e-4a0f-8e1b-a20856d2ffc1.png" width="440">
</p>

#### _Strengths_
- Follows a clear and precise structure.
- Works well for small projects
- Transparency will not be an issue for both parties.
- Robust transfer of information from one phase to another because of its systematic approach.

#### _Weaknesses_
- High risk and uncertainty.
- It doesn’t encourage active participation of customers.
- Inadequate for long-term projects.
- Not appropriate for projects with a moderate to high probability of change in requirements.

## 2. Agile
The Agile methodology was developed as a response to growing frustrations with Waterfall and other highly structured, inflexible methodologies. This approach is designed to accommodate change and the need to produce software faster. It aims to reduce risks such as bugs, cost overruns and sudden changes in software requirements.

Using the Agile approach, teams develop in short _iterations_ (also called _sprints_ in Scrum), each of which includes a defined duration and list of deliverables, but in no particular order. During iterations, teams work towards the goal of delivering working software (or some other tangible, testable output).

Agile is collaboration-heavy, focusing on team strengths and efficiency, along with internal feedback from various departments and customers. Customer satisfaction is the highest priority with the Agile approach, which teams achieve by continuously delivering working, tested, prioritized features.

#### Project lifecycle

The Agile lifecycle typically consists of six phases, found below, that can vary slightly based on the project methodology variant being used by the organization. The core of the agile workflow process lifecycle lies in experimentation and adaptability. 

1. **Concept**. Envision and prioritize projects.
2. **Inception**. Identify team members, appointment of funds, and discussion of initial environments and requirements.
3. **Iteration**. The development team works to deliver working software based on iteration requirements and feedback.
4. **Release**. Quality assurance (QA) testing, internal and external training, documentation development, and the iteration is put into production.
5. **Production**. Ongoing software support.
6. **Retirement**. End-of-life activities, including customer notification and migration.
There may be many projects operating simultaneously, multiple iterations running on different product lines, and a variety of customers, both external and internal, with a range of business needs.

#### Iteration workflow
Agile _iterations_ are usually between two to four weeks long, with a final completion date pre-established.
<p align="center">
  <img src="https://user-images.githubusercontent.com/47757441/211388455-eb90c032-d5da-4808-a72d-dbde3cc8d65d.png" width="290">
</p>

1. **Requirements**. Define the deliverables for each iteration based on the product backlog. Product backlogs are lists made from the review/feedback stage of the previous iterations. This is often the most crucial stage of an iteration.
2. **Design**. The software development team will layout the project groundwork. From there, team members can collaborate to analyze each item. The discussion should include planning out the best course of action, best framework, and the best tools to achieve the best quality. The usage of diagrams and product mock-up are recommended during this stage.
3. **Development**. The team develops the next version of the software based on the requirements defined in the first stage.
4. **Testing**. Also called quality assurance (QA) more broadly, this part of the iteration process includes the development of the documentation, internal and external training, and QA testing.
5. **Deployment / Delivery**. The team integrates and delivers the working version of the software into production. Deliver your backlog items to your customer base for the final stage of testing.
6. **Review / Feedback**. The team elicits, analyzes, and uses feedback from the customer and other stakeholders to shape the next iteration's requirements. All feedback should be reviewed in the next iteration. Thus, starting another iteration workflow cycle.

#### _Strengths_
- Face-to-face conversation with team members and customers.
- Ensure and promote customer satisfaction.
- Adapts well with changing requirements.
- Fast and continuous development.
- Easy to manage with more flexibility.


#### _Weaknesses_
- Lack of formal documentation and designing.
- Difficulty in testing and test construction. Testing should be conducted continuously by the Agile team to ensure continuous development progress.
- Overall, it requires more time and energy from everyone.

## 3. Rapid
Rapid Application Development (RAD) is an agile project management strategy where the key benefits are efficiency and fast delivery, making it an attractive choice for developers working in a fast-paced environment. This rapid pace is made possible by RAD’s focus on minimizing the planning stage and maximizing prototype development. 

The end goal of the whole methodology is to deliver working software products to the market faster, as the demand for new applications is ever increasing. It is designed to be flexible to changes and to accept new inputs, like feedback and features, at every stage of the development process.
<p align="center">
  <img src="https://user-images.githubusercontent.com/47757441/211629997-fdf50d41-afa8-4265-b84e-f5ebd4d3947d.png" width="500">
</p>

1. **Requirements**. Rather than spending months developing specifications with customers, RAD begins by defining a loose set of requirements. "Loose" because among the key principles of rapid application development is the permission to change requirements at any point in the cycle.
2. **Prototype**. Once a project has been scoped, teams begin building out the initial models and prototypes. The goal is to rapidly produce a working design that satisfies all or only a portion of requirements. This prototype may cut corners to reach a working state, and that’s acceptable.
3. **Construction & Feedback gathering**. Rapid construction is where application coding, system testing, and unit integration occurs, converting prototype and beta systems into a working model. This stage may also be repeated as required, supporting new components and alterations. The majority of problems and customer changes were addressed during the iterative prototyping stage.
4. **Cutover**. During this stage, developers may optimize or even re-engineer their implementation to improve stability and maintainability. They may also spend this phase connecting the back-end to production data, writing thorough documentation, and doing any other maintenance tasks required before handing the product over with confidence.

#### _Strengths_
- Quick iterations drastically reduce development time and clients receive a working product within a shorter time frame.
- Development is focused on specific customer requirements, instead of building features that could be removed from the final product, which saves time and money.
- Due to the constant feedback, developers can handle and resolve any issues in a timely manner, while ensuring a high-quality product.

#### _Weaknesses_
- It can be difficult to scale RAD, especially when working with larger teams, as this often requires frequent meetings with stakeholders in order to receive feedback. A small team can easily sync with each other, however, inter-team communication can slow down the process.
- Some developers can ignore best practices on the backend to accelerate development of the frontend focused prototype (interface-focus).
- If developers are not committed to delivering software on time, RAD projects can fail. For that reason it requires highly skilled professionals.

## 4. Scrum
TODO

## 5. Kanban
TODO

## 6. Lean
TODO

## 7. DevOps
TODO
