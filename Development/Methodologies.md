<h1 align='center'>Methodologies</h1>

Copyright &copy; 2025, Pexers (https://github.com/Pexers)

Software development methodologies (SDMs) can help a team to complete a project seamlessly. Selecting the right development methodology for a product organization depends largely on the team size, goals, and other factors. 

Almost all software development methodologies are non-technical. This means they do not deal with the technical aspects of software design and development. They focus more on the internal operations, and other processes involved in the project.

### Fundamental roles
These roles can have different naming conventions depending on the adopted methodology:
- **Product Owner**: understands the customer and business requirements, creates and manages the product backlog based on those requirements.
- **Team Leader** / **Scrum Master**: responsible for gluing everything together and ensuring that agile is being done well. In practical terms, that means they help the product owner to define value, the development team to deliver the value and get better. The team leader is a servant leader which not only describes a supportive style of leadership but describes what they do on a day-to-day basis.
- **Development Team**: composed of professionals who do the hands-on work of completing the tasks in a iteration / scrum sprint.
- **Stakeholders**: those who have an interest in the project that is being undertaken. They can be internal or external to the organization, and they may have a financial, operational, or strategic interest in the project.
- **Customers**: individuals who receive or purchase a product or service. A customer should have the ability to buy or rate this product or service. The feedback is frequently used to improve organizational processes and set requirements.

## 1. Waterfall
When it comes to software development, Waterfall is the most traditional and sequential choice. Although it's usually viewed as an outdated method, it's helpful to understand its structure to better appreciate the flexibility of more modern methodologies.

Waterfall requires plenty of structure and documentation up front. It is divided into self-contained stages. The first stage is vital, requiring a full understanding by both developers and stakeholders of the project's demands and scope before anything begins.
<p align="center">
  <img src="https://user-images.githubusercontent.com/47757441/211622541-7b499331-472e-4a0f-8e1b-a20856d2ffc1.png" width="440">
</p>

#### _Strengths_
- Follows a clear and precise structure.
- Works well for small projects
- Transparency will not be an issue for both parties.
- Robust transfer of information from one phase to another because of its systematic approach.

#### _Weaknesses_
- High risk and uncertainty.
- It doesn't encourage active participation of stakeholders.
- Inadequate for long-term projects.
- Not appropriate for projects with a moderate to high probability of change in requirements.

## 2. Agile
The Agile methodology was developed as a response to growing frustrations with Waterfall and other highly structured, inflexible methodologies. This approach is designed to accommodate change and the need to produce software faster. It aims to reduce risks such as bugs, cost overruns and sudden changes in software requirements.

Using the Agile approach, teams develop in short _iterations_ (also called _sprints_ in Scrum), each of which includes a defined duration and list of deliverables, but in no particular order. During iterations, teams work towards the goal of delivering working software (or some other tangible, testable output).

Agile is collaboration-heavy, focusing on team strengths and efficiency, along with internal feedback from various departments and customers. Customer satisfaction is the highest priority with the Agile approach, which teams achieve by continuously delivering working, tested, prioritized features.

### Project lifecycle

The Agile lifecycle typically consists of six phases, found below, that can vary slightly based on the project methodology variant being used by the organization. The core of the agile workflow process lifecycle lies in experimentation and adaptability. 

1. **Concept**. Envision and prioritize projects.
2. **Inception**. Identify team members, appointment of funds, and discussion of initial environments and requirements.
3. **Iteration**. The development team works to deliver working software based on iteration requirements and feedback.
4. **Release**. Quality assurance (QA) testing, internal and external training, documentation development, and the iteration is put into production.
5. **Production**. Ongoing software support.
6. **Retirement**. End-of-life activities, including customer notification and migration.

There may be many projects operating simultaneously, multiple iterations running on different product lines, and a variety of stakeholders, both external and internal, with a range of business needs.

### Iteration workflow
Agile _iterations_ are usually between two to four weeks long, with a final completion date pre-established.
<p align="center">
  <img src="https://user-images.githubusercontent.com/47757441/211388455-eb90c032-d5da-4808-a72d-dbde3cc8d65d.png" width="290">
</p>

1. **Requirements**. Define the deliverables for each iteration based on the product backlog. Product backlogs are lists made from the review/feedback stage of the previous iterations. This is often the most crucial stage of an iteration.
2. **Design**. The software development team will layout the project groundwork. From there, team members can collaborate to analyze each item. The discussion should include planning out the best course of action, best framework, and the best tools to achieve the best quality. The usage of diagrams and product mock-up are recommended during this stage.
3. **Development**. The team develops the next version of the software based on the requirements defined in the first stage.
4. **Testing**. Also called quality assurance (QA) more broadly, this part of the iteration process includes the development of the documentation, internal and external training, and QA testing.
5. **Deployment / Delivery**. The team integrates and delivers the working version of the software into production. Deliver your backlog items to your customer base for the final stage of testing.
6. **Review / Feedback**. The team elicits, analyzes, and uses feedback from customers and stakeholders to shape the next iteration's requirements. All feedback should be reviewed in the next iteration. Thus, starting another iteration workflow cycle.

#### _Strengths_
- Adapts well with changing requirements.
- Ensure and promote customer satisfaction.
- Face-to-face conversation with team members and stakeholders.
- Fast and continuous development.
- Easy to manage with more flexibility.

#### _Weaknesses_
- Lack of formal documentation and designing.
- Difficulty in testing and test construction. Testing should be conducted continuously by the Agile team to ensure continuous development progress.
- Overall, it requires more time and energy from everyone.

## 3. Rapid
Rapid Application Development (RAD) is an agile project management strategy where the key benefits are efficiency and fast delivery, making it an attractive choice for developers working in a fast-paced environment. This rapid pace is made possible by RAD's focus on minimizing the planning stage and maximizing prototype development. 

The end goal of the whole methodology is to deliver working software products to the market faster, as the demand for new applications is ever increasing. It is designed to be flexible to changes and to accept new inputs, like feedback and features, at every stage of the development process.
<p align="center">
  <img src="https://user-images.githubusercontent.com/47757441/211629997-fdf50d41-afa8-4265-b84e-f5ebd4d3947d.png" width="500">
</p>

1. **Requirements**. Rather than spending months developing specifications with stakeholders, RAD begins by defining a loose set of requirements. "Loose" because among the key principles of rapid application development is the permission to change requirements at any point in the cycle.
2. **Prototype**. Once a project has been scoped, teams begin building out the initial models and prototypes. The goal is to rapidly produce a working design that satisfies all or only a portion of requirements. This prototype may cut corners to reach a working state, and that's acceptable.
3. **Construction & Feedback gathering**. Rapid construction is where application coding, system testing, and unit integration occurs, converting prototype and beta systems into a working model. This stage may also be repeated as required, supporting new components and alterations. The majority of problems and customer changes were addressed during the iterative prototyping stage.
4. **Cutover**. During this stage, developers may optimize or even re-engineer their implementation to improve stability and maintainability. They may also spend this stage connecting the back-end to production data, writing thorough documentation, and doing any other maintenance tasks required before handing the product over with confidence.

#### _Strengths_
- Quick iterations drastically reduce development time and customers receive a working product within a shorter time frame.
- Development is focused on specific stakeholder requirements, instead of building features that could be removed from the final product, which saves time and money.
- Due to the constant feedback, developers can handle and resolve any issues in a timely manner, while ensuring a high-quality product.

#### _Weaknesses_
- It can be difficult to scale RAD, especially when working with larger teams, as this often requires frequent meetings with stakeholders in order to receive feedback. A small team can easily sync with each other, however, inter-team communication can slow down the process.
- Some developers can ignore best practices on the backend to accelerate development of the frontend focused prototype (interface-focus).
- If developers are not committed to delivering software on time, RAD projects can fail. For that reason it requires highly skilled professionals.

## 4. Scrum
Scrum is a system development methodology that implements agile development. The primary goal of Scrum is to satisfy the customer's need through an environment of transparency in communication, collective responsibility and continuous progress.

Team members break down end goals into smaller goals at the beginning and work through them using fixed-length _sprints_ to build software and showcase it often, which usually last two weeks. Meetings play an important role in the Scrum approach, and during each sprint, daily planning meetings and demos take place to follow progress and gather feedback.

Scrum incorporates the structure and discipline of more traditional software development methodologies with the flexibility and iterative practices of modern Agile.
<p align="center">
  <img src="https://user-images.githubusercontent.com/47757441/211806333-ef489d89-5ed9-4b1e-8314-0932ca4362eb.png" width="450">
</p>

1. **Planning**. Defines what is going to be done in the sprint and how it is going to be done. This meeting is held at the beginning of each sprint and determines how to approach the project coming from the Product Backlog stages and deadlines. Each sprint is composed of different features.
2. **Implementation & Daily Scrum**. The objective of the Daily Scrum is to evaluate the progress and trend until the end of the sprint, synchronizing the activities and creating a plan for the next 24h. It is a brief meeting that takes place daily where three questions must be answered individually:  What did I do yesterday? What am I going to do today? What help do I need? The Scrum Master should try to solve problems or obstacles that arise.
3. **Review**. The goal of the sprint review is to show what work has been completed with regards to the Product Backlog for future deliveries. This can allow the team and key stakeholders to work together to brainstorm ideas for further improvements. This stage will determine if completed tasks can be removed from the backlog, or need to be added back.
4. **Retrospective**. This stage serves to implement improvements from the point of view of the development process. The goal of the sprint retrospective is to identify possible process improvements and generate a plan to implement them in the next sprint.

#### _Strengths_
- Large projects are divided into easily manageable sprints.
- Scrum, being agile, adopts feedback from customers and stakeholders.
- The team gets clear visibility through scrum meetings.
- The individual effort of each team member is visible during daily scrum meetings

#### _Weaknesses_
- The workflow can be easily compromised if individuals aren't very committed or cooperative.
- Difficult to estimate the resources, it lacks the end-to-end visibility of the software development process.

## 5. DevOps
DevOps makes the developers (Dev) - experts in coding - and the operations engineers (Ops) - experts in monitoring, management, and control of the IT infrastructure - work together to ensure that services are delivered according to organizational policies, requirements, and performance standards. Operation teams comprise of a range of cross-functional experts, including security, systems, and network engineers. This is what DevOps intends to do, taking the best parts of both disciplines.

A DevOps engineer introduces processes, tools, and methodologies to balance needs throughout the software development life cycle, from coding and deployment, to maintenance and updates. This role should not be confused with an Site Reliability Engineer (SRE), whose work has historically been done by an Operations team, but using engineers with software expertise, and banking on the fact that these engineers are inherently both predisposed to, and have the ability to, substitute automation for human labor. 

Continuous Integration, Delivery and Deployment (CI/CD) are practices that seek to speed up the process of releasing software by shortening feedback loops and automating repetitive tasks. These practices play a key role in making the agile principle of frequently delivering valuable, working software to users a reality. A DevOps engineer uses a CI/CD tool such as Jenkins, GitHub Actions, GitLab CI/CD, CircleCI, AWS CodeBuild, Azure DevOps, Atlassian Bamboo, etc. to automate the steps and provide reporting.
<p align="center">
  <img src="https://user-images.githubusercontent.com/47757441/212539744-e9008ff5-50b8-45d0-b3b5-23c83a8d39cc.png" width="360">
</p>

### Foundations
- **Continuous Integration, Delivery and Deployment (CI/CD)**
  1. _Continuous Integration_: automatically building and unit testing an entire application whenever a code change is checked into source control by developers regularly. If something breaks, there are far fewer changes to go through in order to find the source of the problem. Getting feedback quickly to developers also makes it easier to fix any issues, because they don't lose the context of what they were doing. At this stage we can also use a static code analysis tool, such as SonarQube, to evaluate code quality and look for evident security vulnerabilities.
  2. _Continuous Delivery_: an extension of continuous integration where each successful build is automatically deployed to each of the **pre-production** environments, with confidence in the quality increasing with every stage. These can be testing environments for additional layers of testing, such as security, load and performance tests; sandbox environments for support and sales teams to familiarize themselves with new features; and acceptance testing environments for QA and product professionals to verify that changes work as intended.
  3. _Continuous Deployment_: if a build passes all previous stages in the pipeline successfully, it is automatically released to **production**. Continuous deployment shortens the feedback loop from code change to use in production, giving the team timely insight into how their changes perform in the real world without having to compromise on quality. Even with all the previous measures in place, continuous deployment can feel like a risky practice. What happens if a bug goes undetected in testing only to emerge in production? Time, money and reputation are all potentially at stake. This is where being proactive in looking for signs of trouble rather than waiting for bug reports to come in makes all the difference. Monitoring stats for any change from the norm, particularly just after a release, can alert engineers to issues before they cause a noticeable problem for users.
- **DevSecOps**: stresses the importance of incorporating security into the software development lifecycle (SDLC). Building security into your team's culture, process and tools avoids silos (system parts isolated from the rest) and ensures that rapid delivery is not at the expense of security vulnerabilities.

### Best practices
1. Prioritize customer satisfaction.
2. Active participation of stakeholders.
3. Make use of agile methodologies.
4. Implement CI/CD.
5. Implement test automation.
6. Monitor the right metrics.
7. Integrated change management.
8. Observability.
9. Switch to microservices.
10. Build a collaborative culture.

#### _Strengths_
- Detect configuration errors and programming bugs earlier.
- Improves collaboration and efficiency.
- Faster development and delivery of software.

#### _Weaknesses_
- Lacks standardization, businesses that adopt DevOps may need to create their own customized process and toolsets, which can be time-consuming and costly.
- Often leads to an increase in complexity within an organization's IT infrastructure due to the integration of multiple tools and technologies, making it more difficult to manage and troubleshoot.
- Requires highly experienced professionals.

## 6. Lean
A DevOps methodology focusing on using small batches of work, work-in-progress limits, feedback loops, and visualization. It is based on the philosophy of optimizing development time and resources in the manufacturing process while eliminating waste and maximizing value to the customer.

Agile is an excellent methodology for the practical application of development best practices, but it does not include instructions for scaling these practices across the organization or applying them outside of development-type work.
<p align="center">
  <img src="https://user-images.githubusercontent.com/47757441/212072107-d737677d-7ae0-4804-83a2-b977be2d6eaa.png" width="400">
</p>

- **Eliminate waste**. Eliminates anything that does not add value to the customer, such as unnecessary code, unclear goals, additional features, extra processes, etc.
- **Create knowledge**. Encourages lean teams to do code reviews, perform training, code comments, project documentation, pair programming, sharing sessions, etc.
- **Build quality**. In trying to ensure quality, many teams actually create waste through excessive testing of code or mistakes in logging and resolving them, which takes time and pushes development costs higher. Lean strives to address such issues before they occur.
- **Fast delivery**. Every business strives to deliver fast, to supply value to the customers as quickly as possible. However, there are a few issues that could slow them down like, such as excessive planning, blockers that are not dealt with immediately or over-engineering solutions and business needs.
- **Empower your team**. When things go south or not according to plan, the focus should be kept on checking for gaps in the work process that might have led to conflicts and challenges. 
Lean development encourages respect for people with proactive communication, encouraging healthy conflict, solving work-related issues as a team and empowering each other to work better.
- **Delay decision making** / **Defer Commitment**. Deciding late is not equal to becoming irresponsible. In fact, it encourages the team to keep their options open for a long period of time so that they can gather data which can help in taking important decisions. 
- **Optimize the whole**. Lean software development teams often fail due to releasing sloppy code for the sake of speed or overloading of testers. Optimizing the whole encourages businesses to reduce these issues by operating with an improved understanding of capacity and downstream effects of work. The sequence of activities needed to design, produce and deliver a product or service to customers must be optimized in order to deliver maximum value.

#### _Strengths_
- Reduces resource wastage which optimizes the software development process.
- Empowerment of the development team helps in developing the decision making ability of the team members which creates a more motivated team.

#### _Weaknesses_
- Project success is highly dependent on how disciplined the team members are and how exceptional are their technical skills.
- Project stakeholders need to know what they want and make decisions they will stick to in order to enable fast development and optimize costs. The problem is that stakeholders tend to be paralyzed by fear when it comes to making the tough decisions.

## 7. Kanban
Kanban is a popular lean workflow methodology for defining, visualizing, managing, and improving software development continuously. Work is represented on _kanban boards_. A _board_ is an agile project management tool designed to help visualize work, limit work-in-progress, and maximize efficiency. More over, a _kanban card_ represents a single work item as it moves through various stages of completion which are represented on either a physical or virtual _kanban board_.
<p align="center">
  <img src="https://user-images.githubusercontent.com/47757441/212106433-48a2e8c7-56b8-4f38-a0a9-ae46bd9940c1.png" width="430">
</p>

#### _Strengths_
- Very simple and easy to understand approach, doesn't require putting the whole team through a training course.
- Supervision of the use of a kanban board, cards, and analysis of the output is easier as compared to most approaches of project management.
- Encourages collaboration given that everyone can easily identify when a team member is falling behind. This should lead to a greater team effort in order to help those professional where needed. 

#### _Weaknesses_
- As the tasks are continuously shifted between the columns of the _kanban board_, the prediction of specific timelines for completion of tasks or activities becomes difficult.
- Kanban will become very difficult to apply if too much activities or tasks are interrelated in a system.
- There's a lack of explicit iteration. When a card reaches the end of the board, the task is given as completed and usually forgotten after a while. For instance, there's no information of it being a first attempt that needs refinement.

## Tools
- Jira
- Trello
